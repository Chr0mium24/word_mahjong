**项目名称：字牌风云 (Word Mahjong)**

#### **1. 项目概述**

“字牌风云”是一款基于Web的多人在线文字组合游戏，其灵感源于麻将，但以汉字卡牌的自由组合与社交判断取代了传统的牌型规则。游戏的核心在于玩家的创造力、语言组织能力以及说服他人的能力。玩家需要利用手中的“字”牌，通过摸牌、打牌、“吃”牌来组合成有意义、有韵味甚至有趣的诗句或句子。当玩家认为自己的牌在画布上组合完毕（“胡”）或希望利用上家的牌组成词语（“吃”）时，必须发起一次全体投票。只有在规定时间内获得除自己外**至少两名**其他玩家的“同意”，操作才能成功。这是一个考验语言智慧与社交博弈的“文人”麻将。

**1.5 界面风格**
游戏采用横屏布局。屏幕下半部分约40%是玩家专属的**个人创作画布**，这是一个二维空间，玩家可以在此自由拖动、排列自己的手牌，牌与牌之间有网格吸附效果，**确保它们对齐且不能重叠**。画布之外的区域用于展示公共信息：中央是所有玩家打出的弃牌池，同时会渲染其他三位玩家的牌背视图及其公开的“吃”牌组合。

---

#### **2. 核心玩法机制**

* **基本流程**: 每局游戏四人参与。每位玩家起手13张字牌。轮到自己时，系统自动摸一张新牌，玩家有20秒时间思考并双击打出一张最不需要的牌。若超时未打，则系统自动打出刚摸到的那张牌。
* **胡牌 (Win)**: 当玩家认为自己手中的所有牌（包括起手牌、摸到的牌以及所有公开的“吃”牌组合）已经可以**全部用上**，共同组成一句或多句通顺、有意义或有艺术感的诗句/句子时，可以宣布“胡牌”。宣布后，该玩家在个人画布上的牌面布局将对所有其他玩家公开，以供投票。
* **吃牌 (Chow)**: **仅当上家**打出一张字牌，而你认为这张牌可以与你手中的任意两张牌组合成一个有意义的词语时，你可以选择“吃”。点击“吃”后，你需要从手牌中选出对应的两张牌并公开。这三张牌（上家打的1张 + 你自己的2张）将作为一个组合，**像麻将一样横置在你的牌堆前，永久公开**，然后你需要从剩余手牌中打出一张。
* **操作优先级**: 当一名玩家打出一张牌后，其他玩家可能可以对这张牌进行“吃”或“胡”的操作。服务器将遵循麻将规则，**“胡”的优先级高于“吃”**。若有多个玩家可以“胡”这张牌，则按逆时针顺序，离打牌者最近的玩家优先。
* **流局 (Draw)**: 如果牌墙的所有牌都被摸完，但仍然没有玩家成功“胡牌”，则本局游戏为“流局”。本局不进行计分，所有玩家准备后直接开始新的一局。
* **社交投票机制 (核心)**:

  * 无论是“胡”还是“吃”，发起后都会立即触发一次对所有其他玩家的投票。
  * **通过条件**: 操作必须获得**至少两位**其他玩家的“同意”票才算成功。发起投票的玩家本人不需要投票。
  * **投票时限**: 投票时间为10秒。其他玩家的界面会弹出投票窗口，并显示倒计时。
  * **默认同意**: 在10秒内未做出选择的玩家，系统将视为“同意”。
  * **结果**:
    * **投票通过**: “胡牌”则游戏结束，该玩家获胜，进入结算界面；“吃牌”则将该组合收入自己牌面，并打出一张手牌，轮到下家摸牌。
    * **投票失败**: 若未能获得至少两票“同意”（即有两名或以上的玩家投了“反对”），则操作失败。
      * **“吃”失败**: 游戏继续，轮到原顺序的下家摸牌。
      * **“胡”失败 (惩罚机制)**: 若是“胡牌”投票失败，**该玩家在自己的下一个出牌回合内不能再次宣告“胡牌”**。游戏继续，轮到原顺序的下家摸牌。

---

#### **3. 核心技术栈**

* **前端UI框架 (Application Shell)**: React
* **UI样式库 (Styling)**: Tailwind CSS
* **2D图形渲染库 (Game Canvas)**: Konva.js
* **后端 & 实时通信**: Node.js + Express + Socket.IO

---

#### **4. 功能模块详述**

**4.1. 应用外壳与UI (React + Tailwind CSS)**

* **组件**:
  * `Lobby`: 游戏入口界面。提供加入房间的输入框和创建房间的按钮。
  * `CreateRoom`: 创建房间界面，能够自定义投票时间、打牌时间。
    * **自定义牌库**: 提供一个**文本输入框**用于输入自定义牌库内容。
      * **逻辑**: 房主输入一串汉字。点击创建后，系统检查字符串长度。若长度**不足144**，则循环使用用户输入的字符来填充至144个，并提示用户“您提供的字库不足144个，已为您循环填充”。若长度**超过144**，则只截取前144个字，并提示用户“您提供的字库超过144个，已为您截取前144个字”。
  * `GameUI`: 围绕Canvas的游戏界面外壳。
    * `PlayerInfo`: 显示当前玩家、在线列表、各玩家公开的“吃”牌组合及弃牌区。
    * `ActionButtons`: “吃”、“胡”等操作按钮。仅在满足条件时（例如没有被惩罚）激活。
  * `VoteModal`: 核心UI组件。当有玩家发起“吃”或“胡”时，为所有其他玩家弹出此模态框。
    * **内容**: 清晰展示发起者的意图（“玩家A试图‘吃’牌组成 ‘XXX’”、“玩家B宣布‘胡’了，其牌组为 [展示其画布布局]”）。
    * **交互**: 包含“同意”和“反对”按钮，以及一个醒目的10秒倒计时。
  * `ScoreboardModal`: 游戏单局结束后弹出的计分板，显示本局得分、总分，并包含“再来一局”的准备按钮。
* **职责**:
  * 处理用户输入（登录、点击按钮、提交投票）。
  * 通过状态管理将数据传递给Canvas组件。
  * 监听Socket.IO事件，并根据事件更新UI（例如，根据服务器状态禁用“胡”按钮）。

**4.2. 游戏交互画布 (React + Konva.js)**

* **Canvas结构和麻将牌实现**:
  * 使用 `Konva.Stage` 和多 `Konva.Layer` 结构。麻将牌由 `Konva.Group` (包含 `Konva.Rect` 和 `Konva.Text`) 构成。
  * 麻将牌在画布上可以被拖动，并自动吸附到预设的网格上，**禁止牌与牌之间发生重叠**。
* **核心交互逻辑**:
  * **拖放 (整理手牌)**: **手牌的整理完全在客户端进行**，监听 `dragend` 事件只更新本地的组件状态，不与服务器通信。
  * **打牌 (双击)**: 绑定 `dblclick` 事件，向服务器发送 `playTile({ tileId })` 事件。
  * **胡牌展示**: 当“胡牌”投票开始时，根据服务器广播的数据，渲染胡牌玩家的最终画布布局给所有投票者。（实现时可考虑将布局生成为图片再广播，以降低同步复杂度和性能开销）。

**4.3. 服务器端逻辑 (Node.js + Socket.IO)**

* **状态权威 (Single Source of Truth)**: 服务器是游戏状态的唯一决策者。
* **游戏状态对象 (Game State Object)**:

  ```json
  {
    "roomId": "unique-room-id",
    "players": { 
      "player-id-1": { "info": {}, "score": 0, "status": "online", "penalty": "none" | "cannot_win_next_turn" }
    },
    "wall": [ /* 牌墙剩余的牌 */ ],
    "turn": "player-id-1",
    "turnExpiresAt": "timestamp",
    "gameState": "playing" | "voting" | "ended",
    "discards": [ /* 公共弃牌堆 */ ],
    "melds": { /* 各玩家公开的'吃'牌组合 */ },
    "currentVote": null | { /* 投票详情 */ }
  }
  ```
* **投票逻辑**:

  1. 玩家客户端发起 `claimAction` 请求。
  2. 服务器验证请求合法性（时机、牌、玩家是否处于惩罚状态等）。
  3. 服务器切换 `gameState` 为 `voting`，填充 `currentVote` 对象，并向除发起者外的所有玩家广播 `startVote` 事件。
  4. 服务器启动倒计时。期间接收 `submitVote` 事件。
  5. 倒计时结束或所有人都投票后，服务器计算结果：
     * 将所有未投票的玩家（`'pending'`）计为 `'approve'`。
     * 统计 `'approve'` 票数。若 **`approve` 票数 >= 2**，则投票成功。
  6. 服务器广播结果。若投票失败且类型为“胡牌”，则更新该玩家状态，施加“下一回合无法胡牌”的惩罚。
* **断线重连与托管逻辑**:

  1. 当玩家断开连接，服务器记录其 `disconnectTime`并向其他玩家广播 `playerDisconnected`事件。
  2. 为该玩家启动3分钟的重连计时器。
  3. **重连成功**: 若玩家在时限内重连，服务器验证其身份，并向其私信当前完整的游戏状态。
  4. **重连失败 (进入托管)**: 若超过时限，该玩家进入“托管”状态。轮到该玩家时，系统将**自动为其摸牌，并立即打出刚摸到的那张牌**。托管玩家无法主动进行“吃”、“胡”操作。**在任何投票环节，托管玩家都将被系统自动记为“同意”票**。

---

#### **5. 游戏流程与计分机制**

* **计分**:
  * **基础分**: 成功“胡牌”的玩家获得固定的基础分（例如10分）。
  * **奖励分**: (可选迭代) 可根据“胡牌”的质量给予额外奖励。
  * **结算**: 其他三位玩家不扣分，或象征性地扣少量分数。
* **游戏结束后流程**:
  1. 当有玩家“胡牌”成功，服务器广播 `gameEnd` 事件。
  2. 客户端弹出 `ScoreboardModal`，展示计分板。
  3. 玩家点击“再来一局”按钮。当房间内所有玩家都准备好后，服务器自动开启新局。

---

#### **6. 关键WebSocket事件流**

* **Client -> Server**:

  * `joinRoom({ username, roomId })`
  * `createRoom({ ..., customDeck: '...' })`
  * `playTile({ tileId })`
  * `claimAction({ type: 'chow' | 'win', tiles: [...] })`
  * `submitVote({ decision: 'approve' | 'deny' })`
  * `readyForNextGame()`
* **Server -> Client(s)**:

  * `gameStateUpdate(fullGameState)`: (广播) 关键动作后发送完整的游戏状态，其中包含玩家的惩罚状态。
  * `startVote({ ... })`: (广播给投票者) 通知投票开始。
  * `voteResult({ result, type, claimantId, penaltyApplied: true/false })`: (广播) 公布投票结果及是否施加惩罚。
  * `newTile({ tileObject })`: (私信) 向当前回合玩家发送新摸的牌。
  * `turnChanged({ ... })`: (广播) 通知回合变更。
  * `gameEnd({ ... })`: (广播) 游戏结束。
  * `playerConnectionUpdate({ playerId, status: 'disconnected' | 'reconnected' | 'managed' })`: (广播) 通知玩家连接状态变化。

---

#### **7. 实施要点**

* **投票机制的健壮性**: 服务器必须精确处理投票流程，包括状态切换、严格的计时器、默认同意逻辑、托管者投票逻辑和结果计算。
* **清晰的用户反馈**: UI必须在任何时候都让玩家清楚当前的游戏状态：是谁的回合？打牌剩余多少时间？谁在发起什么投票？投票还剩几秒？投票结果是什么？自己是否处于不能胡牌的状态？
* **关注点分离**: 严格分离React（UI逻辑）和Konva（画布渲染）的职责。
* **网络容错性**: 健全的断线重连和托管机制是保证流畅多人体验的基础，必须在服务器端稳妥实现。

---

#### **8. 目录结构建议**

**8.1. 前端 (Frontend) 目录结构**```
/src
├── /components
│   ├── /canvas
│   │   ├── GameCanvas.jsx
│   │   └── Tile.jsx
│   ├── /ui
│   │   ├── ActionButtons.jsx
│   │   ├── GameUI.jsx
│   │   ├── Lobby.jsx
│   │   ├── CreateRoom.jsx
│   │   ├── PlayerInfo.jsx
│   │   ├── VoteModal.jsx
│   │   └── ScoreboardModal.jsx
│   └── App.jsx
├── /context
│   ├── GameStateContext.jsx
│   └── SocketContext.jsx
├── /hooks
│   └── useSocketListener.js
└── index.js

```

**8.2. 后端 (Backend) 目录结构**```
/server
├── /config                 // 配置文件，如环境变量
│   └── index.js
├── /game                   // 核心游戏逻辑，与网络层解耦
│   ├── Game.js             // 管理单个游戏房间状态的类
│   ├── Player.js           // 玩家类
│   └── Deck.js             // 牌库生成、洗牌、发牌逻辑
├── /socket                 // Socket.IO 事件处理中心
│   ├── index.js            // 主Socket连接器，分发事件
│   ├── roomHandlers.js     // 处理创建、加入、离开房间等事件
│   └── gameHandlers.js     // 处理打牌、吃、胡、投票等游戏核心事件
├── /utils                  // 通用工具函数
│   └── helpers.js          // 例如：生成房间ID、随机数等
├── app.js                  // Express应用配置和中间件
└── server.js               // 服务器主入口文件 (创建HTTP服务器并绑定Socket.IO)
```
